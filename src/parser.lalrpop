use crate::ast::*;

grammar;

pub Expr: Box<dyn Expression> = ExprFunction;

ExprFunction: Box<dyn Expression> = {
    <arg:Ident> ":" <body:ExprFunction> => Box::new(FunctionLiteralExpr::new(Arg::Arg(arg), body)),
    "{" <formals:Formals> "}" ("@" <alias:Ident>)? ":" <body:ExprFunction>
        => Box::new(FucntionLiteralExpr::new(Arg::Formals(formals.0, formals.1, alias), body)),
    <alias:Ident> "@{" <formals:Formals> "}:" <body:ExprFunction>
        => Box::new(FucntionLiteralExpr::new(Arg::Formals(formals.0, formals.1, Some(alias)), body)),

    "assert" <assertion:Expr> ";" <expr:ExprFunction> => Box::new(AssertExpr::new(assertion, expr)),

    "with" <attrs:Expr> ";" <expr:ExprFunction> => Box::new(WithExpr::new(attrs, expr)),

    "let" <binds:Binds> ";" <expr:ExprFunction> => Box::new(LetExpr::new(binds, expr)),

    ExprIf => <>
};

If: Box<dyn Expression> = {
    "if" <cond:Expr> "then" <consq:Expr> "else" <alter:Expr>
             => Box::new(IfExpr::new(cond, consq, alter)),
    ExprOp => <>
};

ExprOp: Box<dyn Expression> = {
    "!" ExprOp => Box::new(OpNotExpr::new(<>)),
    "-" ExprOp => Box::new(OpNegExpr::new(<>)),
    <l:ExprOp> "==" <r:ExprOp> => Box::new(OpEqExpr::new(l, r)),
    <l:ExprOp> "!=" <r:ExprOp> => Box::new(OpNeqExpr::new(l, r)),
    <l:ExprOp> "<" <r:ExprOp> => Box::new(OpLtExpr::new(l, r)),
    <l:ExprOp> "<=" <r:ExprOp> => Box::new(OpLeqExpr::new(l, r)),
    <l:ExprOp> ">" <r:ExprOp> => Box::new(OpGtExpr::new(l, r)),
    <l:ExprOp> ">=" <r:ExprOp> => Box::new(OpGeqExpr::new(l, r)),
    <l:ExprOp> "&&" <r:ExprOp> => Box::new(OpAndExpr::new(l, r)),
    <l:ExprOp> "||" <r:ExprOp> => Box::new(OpOrExpr::new(l, r)),
    <l:ExprOp> "->" <r:ExprOp> => Box::new(OpImplExpr::new(l, r)),
    <l:ExprOp> "//" <r:ExprOp> => Box::new(OpUpdateExpr::new(l, r)),
    <l:ExprOp> "?" <r:ExprOp> => Box::new(OpHasExpr::new(l, r)),
    <l:ExprOp> "+" <r:ExprOp> => Box::new(OpAddExpr::new(l, r)),
    <l:ExprOp> "-" <r:ExprOp> => Box::new(OpSubExpr::new(l, r)),
    <l:ExprOp> "*" <r:ExprOp> => Box::new(OpMulExpr::new(l, r)),
    <l:ExprOp> "/" <r:ExprOp> => Box::new(OpDivExpr::new(l, r)),
    <l:ExprOp> "++" <r:ExprOp> => Box::new(OpConcatExpr::new(l, r)),
    ExprApp => <>
};

ExprApp: Box<dyn Expression> = {
    <func:ExprApp> <arg:ExprSelect> => {
        if func.as_any().is::<FunctionCallExpr>() {
            func.as_any().downcast_mut::<FunctionCallExpr>().unwrap().args.push(arg);
            func
        } else {
            Box::new(FunctionCallExpr::new(func, Vec::new(arg)))
        }
    }
    ExprSelect => <>
};

ExprSelect: Box<dyn Expression> = {
    <attrs:ExprSimple> "." <path:AttrPath> ("or" <default:ExprSelect>)? => Box::new(OpSelectExpr::new(attrs, path, default)),
    ExprSimple => <>
};

ExprSimple: Box<dyn Expression> = {
    Ident => Box::new(IdentifierExpr::new(<>)),
    Int => Box::new(IntLiteralExpr::new(<>)),
    Float => Box::new(FloatLiteralExpr::new(<>)),
    "\"" StringParts "\"" => <>,
    r"''(\ *\n)?" IndStringParts "''" => Box::new(strip_indent(<>)),
    Path => Box::new(<>),
    "<" Path ">" => Box::new(SearchPathExpr::new(<>)),
}

Int: String = r"[0-9]+" => <>.to_string();

Float: String = r"[0-9]*.[0-9]+" => <>.to_string();

Str: StringLiteralExpr = r#""(\\\\|\\"|[^"\\])*""# => StringLiteralExpr::new(<>[1..l.len()-1].to_string());

Ident: String = r"[a-zA-Z_][a-zA-Z0-9_\-]" => <>.to_string();

Formal: (String, Option<Box<dyn Expression>>) = {
    Ident => (<>, None),
    <id:Ident> "?" <default:Expr> => (id, Some(default))
};

Formals: (Vec<(String, Option<Box<dyn Expression>>)>, bool) = {
    <mut v:(<Formal> ",")*> <e:Formal?> => match e { // (2)
        None => (v, false),
        Some(e) => {
            v.push(e);
            (v, false)
        }
    },
    Formals "..." => (<>.0, true)
};

Binds: Vec<(Vec<Box<dyn Expression>>, Box<dyn Expression>)> = {
    
};

Op: Box<dyn Expression> = {
    #[precedence(level="0")] #[assoc(side="none")]
    "!" Op => Box::new(OpNotExpr::new()),
    #[precedence(level="1")] #[assoc(side="none")]
    "-" Op => Box::new(OpNegExpr::new()),
    #[precedence(level="2")] #[assoc(side="none")]
};



/*SumLevelOp: Box<Expression> = {
    <l:Expr> "+" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "-" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}

MulLevelOp: Box<Expression> = {
    <l:Expr> "*" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "/" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}

BoolOp: Box<Expression> = {
    <l:Expr> "&&" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "||" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}*/

/*
    vim:ft=lalrpop
*/
