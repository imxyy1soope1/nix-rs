use crate::ast::*;

grammar;

pub Expr: Box<Expression> = {
    
};

Int: IntLiteralExpr = r"[0-9]+" => IntLiteralExpr::new(<>);

Float: FloatLiteralExpr = r"[0-9]*.[0-9]+" => FloatLiteralExpr::new(<>);

Str: StringLiteralExpr = r#""(\\\\|\\"|[^"\\])*""# => StringLiteralExpr::new(<>[1..l.len()-1].to_string());

Ident: IdentifierExpr = r"[a-zA-Z_][a-zA-Z0-9_\-]" => IdentifierExpr::new(<>.to_string());

Op: Box<dyn Expression> = {
    #[precedence(level="0")] #[assoc(side="none")]
    "!" Op => Box::new(OpNotExpr::new()),
    #[precedence(level="1")] #[assoc(side="none")]
    "-" Op => Box::new(OpNegExpr::new()),
    #[precedence(level="2")] #[assoc(side="none")]
}




If: IfExpr = "if" <cond:Expr> "then" <consq:Expr> "else" <alter:Expr>
             => IfExpr::new(cond, consq, alter)


/*SumLevelOp: Box<Expression> = {
    <l:Expr> "+" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "-" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}

MulLevelOp: Box<Expression> = {
    <l:Expr> "*" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "/" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}

BoolOp: Box<Expression> = {
    <l:Expr> "&&" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "||" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}*/
