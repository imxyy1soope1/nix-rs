use crate::ast::*;

grammar;

pub Expr: Box<dyn Expression> = ExprFunction;

ExprFunction: Box<dyn Expression> = {
    <arg:Ident> ":" <body:ExprFunction> => Box::new(FunctionLiteralExpr::new(Arg::Arg(arg), body)),
    "{" <formals:Formals> "}" ("@" <alias:Ident>)? ":" <body:ExprFunction>
        => Box::new(FucntionLiteralExpr::new(Arg::Formals(formals.0, formals.1, alias), body)),
    <alias:Ident> "@{" <formals:Formals> "}:" <body:ExprFunction>
        => Box::new(FucntionLiteralExpr::new(Arg::Formals(formals.0, formals.1, Some(alias)), body)),

    "assert" <assertion:Expr> ";" <expr:ExprFunction> => Box::new(AssertExpr::new(assertion, expr)),

    "with" <attrs:Expr> ";" <expr:ExprFunction> => Box::new(WithExpr::new(attrs, expr)),

};

Int: IntLiteralExpr = r"[0-9]+" => IntLiteralExpr::new(<>);

Float: FloatLiteralExpr = r"[0-9]*.[0-9]+" => FloatLiteralExpr::new(<>);

Str: StringLiteralExpr = r#""(\\\\|\\"|[^"\\])*""# => StringLiteralExpr::new(<>[1..l.len()-1].to_string());

Ident: String = r"[a-zA-Z_][a-zA-Z0-9_\-]" => <>.to_string();

Formal: (String, Option<Box<dyn Expression>>) = {
    Ident => (<>, None),
    <id:Ident> "?" <default:Expr> => (id, Some(default))
};

Formals: (Vec<(String, Option<Box<dyn Expression>>)>, bool) = {
    <mut v:(<Formal> ",")*> <e:Formal?> => match e { // (2)
        None => (v, false),
        Some(e) => {
            v.push(e);
            (v, false)
        }
    },
    Formals "..." => (<>.0, true)
};

Binds: Vec<(Vec<Box<dyn Expression>>, Box<dyn Expression>)> = {
    
};

Op: Box<dyn Expression> = {
    #[precedence(level="0")] #[assoc(side="none")]
    "!" Op => Box::new(OpNotExpr::new()),
    #[precedence(level="1")] #[assoc(side="none")]
    "-" Op => Box::new(OpNegExpr::new()),
    #[precedence(level="2")] #[assoc(side="none")]
};

If: IfExpr = "if" <cond:Expr> "then" <consq:Expr> "else" <alter:Expr>
             => IfExpr::new(cond, consq, alter)


/*SumLevelOp: Box<Expression> = {
    <l:Expr> "+" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "-" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}

MulLevelOp: Box<Expression> = {
    <l:Expr> "*" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "/" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}

BoolOp: Box<Expression> = {
    <l:Expr> "&&" <r:Expr> => Box::new(OpMulExpr::new(l, r)),
    <l:Expr> "||" <r:Expr> => Box::new(OpDivExpr::new(l, r)),
}*/

/*
    vim:ft=lalrpop
*/
